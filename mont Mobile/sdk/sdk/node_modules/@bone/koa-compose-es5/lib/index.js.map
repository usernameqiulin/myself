{"version":3,"sources":["../src/index.js"],"names":["module","exports","compose","middleware","Array","isArray","TypeError","fn","context","next","index","dispatch","i","Promise","reject","Error","length","resolve","err"],"mappings":"AAAA;;AAEA;;;;AAIAA,OAAOC,OAAP,GAAiBC,OAAjB;;AAEA;;;;;;;;;;AAUA,SAASA,OAAT,CAAkBC,UAAlB,EAA8B;AAC5B,MAAI,CAACC,MAAMC,OAAN,CAAcF,UAAd,CAAL,EAAgC,MAAM,IAAIG,SAAJ,CAAc,oCAAd,CAAN;AADJ;AAAA;AAAA;;AAAA;AAE5B,yBAAiBH,UAAjB,8HAA6B;AAAA,UAAlBI,EAAkB;;AAC3B,UAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B,MAAM,IAAID,SAAJ,CAAc,2CAAd,CAAN;AAC/B;;AAED;;;;;AAN4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY5B,SAAO,UAAUE,OAAV,EAAmBC,IAAnB,EAAyB;AAC9B;AACA,QAAIC,QAAQ,CAAC,CAAb;AACA,WAAOC,SAAS,CAAT,CAAP;AACA,aAASA,QAAT,CAAmBC,CAAnB,EAAsB;AACpB,UAAIA,KAAKF,KAAT,EAAgB,OAAOG,QAAQC,MAAR,CAAe,IAAIC,KAAJ,CAAU,8BAAV,CAAf,CAAP;AAChBL,cAAQE,CAAR;AACA,UAAIL,KAAKJ,WAAWS,CAAX,CAAT;AACA,UAAIA,MAAMT,WAAWa,MAArB,EAA6BT,KAAKE,IAAL;AAC7B,UAAI,CAACF,EAAL,EAAS,OAAOM,QAAQI,OAAR,EAAP;AACT,UAAI;AACF,eAAOJ,QAAQI,OAAR,CAAgBV,GAAGC,OAAH,EAAY,SAASC,IAAT,GAAiB;AAClD,iBAAOE,SAASC,IAAI,CAAb,CAAP;AACD,SAFsB,CAAhB,CAAP;AAGD,OAJD,CAIE,OAAOM,GAAP,EAAY;AACZ,eAAOL,QAAQC,MAAR,CAAeI,GAAf,CAAP;AACD;AACF;AACF,GAlBD;AAmBD","file":"index.js","sourcesContent":["'use strict'\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n"]}