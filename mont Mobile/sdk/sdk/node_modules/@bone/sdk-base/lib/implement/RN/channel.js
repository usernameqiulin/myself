"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_emitter_1 = __importDefault(require("@bone/event-emitter"));
var logger_1 = __importDefault(require("@bone/logger"));
var bridge_1 = __importDefault(require("./bridge"));
var hub_1 = require("../../hub");
var channel_1 = require("../../interface/channel");
var constants_1 = require("./constants");
var log = logger_1.default.create({
    module: 'ChannelRNImplement',
    label: ['channel', 'sdk'],
});
var innerMessage = Object.assign({}, event_emitter_1.default);
// native downstream event name
var CHANNEL_NA_DOWSTREAM = 'BoneDownstream';
// native connect status change event name
var CHANNEL_NA_CONNECT_STATUS_CHANGE = 'BoneChannelConnectStatusChange';
bridge_1.default.on(CHANNEL_NA_DOWSTREAM, onMessageArried);
bridge_1.default.on(CHANNEL_NA_CONNECT_STATUS_CHANGE, onConnectStatusChange);
function ready() {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve();
        }, 0);
    });
}
exports.ready = ready;
function subTopic(topic, onMessage) {
    // listen to local event dispatcher
    // message will be sent through native event CHANNEL_NA_DOWSTREAM
    innerMessage.on(topic, onMessage);
    if (innerMessage.listenerCount(topic) > 1) {
        return;
    }
    // if it's the first listener
    // subscribe to native
    // so that the topic will be passed through native filter
    bridge_1.default.call(constants_1.MODULE_NAME_NATIVE.CHANNEL, 'subscribe', [topic], function (err) {
        if (err) {
            log.warn("subscribe " + topic + " failed:", err);
            throw err;
        }
    });
}
exports.subTopic = subTopic;
function unsubTopic(topic, onMessage) {
    innerMessage.off(topic, onMessage);
    if (innerMessage.listenerCount(topic) > 0) {
        return;
    }
    // if listener queue is empty, unsubscribe from native
    bridge_1.default.call(constants_1.MODULE_NAME_NATIVE.CHANNEL, 'unsubscribe', [topic], function (err) {
        if (err) {
            log.warn("unsubscribe " + topic + " failed:", err);
            throw err;
        }
    });
}
exports.unsubTopic = unsubTopic;
function publish(topic, payload) {
    return new Promise(function (resolve, reject) {
        bridge_1.default.call(constants_1.MODULE_NAME_NATIVE.CHANNEL, 'publish', [topic, payload], function (err) {
            if (err) {
                log.warn("publish " + topic + " failed:", err);
                reject(err);
                return;
            }
            resolve();
        });
    });
}
exports.publish = publish;
function request(topic, payload) {
    return new Promise(function (resolve, reject) {
        bridge_1.default.call(constants_1.MODULE_NAME_NATIVE.CHANNEL, 'request', [topic, payload], function (err) {
            if (err) {
                log.warn("request " + topic + " failed:", err);
                reject(err);
                return;
            }
            resolve();
        });
    });
}
exports.request = request;
function onMessageArried(msg) {
    hub_1.message.emit(channel_1.EVENT_MESSAGE, msg);
    // dispatch events
    // with err=null
    innerMessage.emit(msg.topic, msg);
}
function onConnectStatusChange(res) {
    hub_1.message.emit(channel_1.EVENT_CONNECT_STATUS_CHANGE, res.status);
}
