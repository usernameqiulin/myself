"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = __importDefault(require("axios"));
var js_cookie_1 = __importDefault(require("js-cookie"));
var WebSimulatorImplement_1 = __importDefault(require("@bone/channel/lib/WebSimulatorImplement"));
var constants_1 = require("@bone/channel/lib/constants");
var channel_1 = require("../../interface/channel");
var hub_1 = require("../../hub");
var channel = new WebSimulatorImplement_1.default({});
channel.on(constants_1.CHANNEL_CONNECT_STATUS_CHANGE, function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    hub_1.message.emit.apply(hub_1.message, [channel_1.EVENT_CONNECT_STATUS_CHANGE].concat(args));
});
function ready(config) {
    if (config && config.mqttOptions) {
        return new Promise(function (resolve) {
            channel.mqttOptions = config.mqttOptions;
            channel.ready([]);
            resolve();
        });
    }
    else {
        var req = {
            url: '/channel',
            method: 'post',
            headers: {
                'x-csrf-token': js_cookie_1.default.get('csrfToken') || '',
            },
        };
        return axios_1.default(req).then(function (res) {
            var options = res.data;
            channel.mqttOptions = options;
            channel.ready([]);
        });
    }
}
exports.ready = ready;
function subTopic(topic, onMessage) {
    channel.subscribe([topic], onMessage);
}
exports.subTopic = subTopic;
function unsubTopic(topic, onMessage) {
    channel.unsubscribe([topic], onMessage);
}
exports.unsubTopic = unsubTopic;
function publish(topic, payload) {
    return new Promise(function (resolve, reject) {
        channel.publish([topic, payload], function (err) {
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}
exports.publish = publish;
function request(topic, payload) {
    return new Promise(function (resolve, reject) {
        channel.request([topic, payload], function (err) {
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}
exports.request = request;
