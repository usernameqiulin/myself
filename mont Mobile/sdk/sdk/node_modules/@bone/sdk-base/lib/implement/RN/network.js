"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var bridge_1 = __importDefault(require("./bridge"));
var constants_1 = require("./constants");
var http_1 = require("../../interface/http");
var netInfo_1 = require("../../interface/netInfo");
var hub_1 = require("../../hub");
var APIGatewayDefaults = {
    version: '1.0.0',
    method: http_1.HTTPMethod.POST,
    data: {}
};
var requestDefaults = {
    url: '',
    method: http_1.HTTPMethod.GET,
    data: {}
};
function APIGateway(path, options) {
    var mergedOptions = Object.assign({}, APIGatewayDefaults, options);
    // @todo
    // https://lark.alipay.com/aone628311/vrby63/aep-mobile-app-bone-mobile-bridge-api-bonerequest
    var method = mergedOptions.method, version = mergedOptions.version, data = mergedOptions.data, withCredential = mergedOptions.withCredential, gateway = mergedOptions.gateway, protocol = mergedOptions.protocol, authType = mergedOptions.authType;
    // case path is url
    var matches = path.match(/^(https?):\/\/([^\/]+)(\/[\s\S]*)$/);
    if (matches) {
        protocol = matches[1];
        gateway = matches[2];
        path = matches[3];
    }
    var config = { host: gateway, scheme: protocol, authType: authType, };
    invariant_1.default(method === http_1.HTTPMethod.POST, 'Only accept post method for now.');
    return new Promise(function (resolve, reject) {
        bridge_1.default.call(constants_1.MODULE_NAME_NATIVE.REQUEST, 'send', [path, version, data, config], function (err, res) {
            if (err) {
                reject(err);
                return;
            }
            resolve(res);
        });
    });
}
exports.APIGateway = APIGateway;
function request(url, options) {
    var mergedOptions = Object.assign({}, requestDefaults, options);
    return fetch(url, mergedOptions);
}
exports.request = request;
// @todo
// Netinfo has bug in elder version, which always returns unkown
// @see https://facebook.github.io/react-native/docs/0.42/netinfo.html#addeventlistener
// const netInfoMappingForAndroid = {
//   NONE: NETWORK_STATUS.NONE,
//   BLUETOOTH: NETWORK_STATUS.OTHERS,
//   DUMMY: NETWORK_STATUS.OTHERS,
//   ETHERNET: NETWORK_STATUS.OTHERS,
//   MOBILE: NETWORK_STATUS.CELL,
//   MOBILE_DUN: NETWORK_STATUS.CELL,
//   MOBILE_HIPRI: NETWORK_STATUS.CELL,
//   MOBILE_MMS: NETWORK_STATUS.CELL,
//   MOBILE_SUPL: NETWORK_STATUS.CELL,
//   VPN: NETWORK_STATUS.OTHERS,
//   WIFI: NETWORK_STATUS.WIFI,
//   WIMAX: NETWORK_STATUS.OTHERS,
//   UNKNOWN: NETWORK_STATUS.UNKNOWN,
// };
// export function fetchNetInfo(): Promise<NETWORK_STATUS>{
//   return new Promise((resolve, reject)=>{
//     NetInfo.fetch().done(reach=>{
//       // ios
//       if( Platform.OS === 'ios' ){
//         resolve(reach || NETWORK_STATUS.UNKNOWN);
//         return;
//       }
//       // android
//       resolve(netInfoMappingForAndroid[reach] || NETWORK_STATUS.UNKNOWN);
//     });
//   });
// }
var netInfoMapping = {
    // 有网时：
    wifi: netInfo_1.NETWORK_STATUS.WIFI,
    '2g': netInfo_1.NETWORK_STATUS.CELL,
    '3g': netInfo_1.NETWORK_STATUS.CELL,
    '4g': netInfo_1.NETWORK_STATUS.CELL,
    cell: netInfo_1.NETWORK_STATUS.CELL,
    // 无网时：
    none: netInfo_1.NETWORK_STATUS.NONE,
    // 其他：
    unknown: netInfo_1.NETWORK_STATUS.UNKNOWN,
};
function fetchNetInfo() {
    return new Promise(function (resolve, reject) {
        bridge_1.default
            .call(constants_1.MODULE_NAME_NATIVE.SYS, 'getNetworkType', [], function (err, rawInfo) {
            if (err) {
                reject(err);
            }
            else {
                resolve(netInfoMapping[rawInfo.type] || netInfo_1.NETWORK_STATUS.UNKNOWN);
            }
        });
    });
}
exports.fetchNetInfo = fetchNetInfo;
// native connect status change event name
var NA_EVENT_NETINFO_CHANGE = 'BoneNetworkStatusChanged';
bridge_1.default.on(NA_EVENT_NETINFO_CHANGE, function (rawInfo) {
    hub_1.message.emit(netInfo_1.EVENT_NETINFO_CHANGE, netInfoMapping[rawInfo.type] || netInfo_1.NETWORK_STATUS.UNKNOWN);
});
