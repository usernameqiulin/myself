'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('./constants');

var _eventEmitter = require('@bone/event-emitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _logger = require('@bone/logger');

var _logger2 = _interopRequireDefault(_logger);

var _pahoClient = require('@bone/paho-client');

var _pahoClient2 = _interopRequireDefault(_pahoClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SYMBOL_CLIENT = Symbol('client');
var SYMBOL_OPTIONS = Symbol('options');

var log = _logger2.default.create({
    module: 'ChannelWebImpl',
    label: ['Bone', 'channel']
});

// @todo
var HOST = {
    development: 'ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:8883/',
    test: 'ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:443/',
    production: 'ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:443/'
};

var RANDOM_RANGE = Math.pow(2, 64);
function createRandom() {
    return Math.floor(Math.random() * RANDOM_RANGE);
}

var UA = function () {
    var ua = navigator.userAgent.toLowerCase();
    var match = /(chrome)[ \/](\w+)\./.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/](\w+)\./.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:(\w+)\.|)/.exec(ua) || [];

    // format: browser_version
    var browser = match[1] || 'unknown';
    var version = match[2] || '0';

    return browser + '_' + version;
}();

var DELIVER_PREFIX = '_ON_MESSAGE_DELIVERED_';

var ChannelWebBridge = function () {
    function ChannelWebBridge(_ref) {
        var bridge = _ref.bridge;

        _classCallCheck(this, ChannelWebBridge);

        // mixin event-emitter for event dispatching
        Object.assign(this, _eventEmitter2.default);
        this.bridge = bridge;
    }

    // fake ready
    // it's useful for web initialization


    _createClass(ChannelWebBridge, [{
        key: 'ready',
        value: function ready(_ref2, callback) {
            var _this = this;

            var _ref3 = _slicedToArray(_ref2, 1),
                conf = _ref3[0];

            var id = conf.id,
                token = conf.token;

            // ready

            if (this.client) {
                callback(new Error('channel: duplicate ready'));
                return;
            }

            if (typeof id !== 'string') {
                callback(new Error('channel: id is required'));
                return;
            }

            if (typeof token !== 'string') {
                callback(new Error('channel: token is required'));
                return;
            }

            var env = this.env = process && process.env && process.env.NODE_ENV ? process.env.NODE_ENV : 'production';
            var host = this.host = HOST[env];

            log.debug('ready: id=' + id + ', token=' + token + ', env=' + env + ', host=' + host);

            var random = createRandom();
            var clientId = id + '_' + random + '&' + UA;
            var mqttClientId = clientId + '|securemode=2,authtype=sepauth|';
            var topicPrefix = '/sys/' + UA + '/' + id + '_' + random + '/web/';
            var clientOptions = {
                host: HOST[env],
                clientId: clientId,
                mqttClientId: mqttClientId,
                mqttUsername: clientId,
                mqttPassword: token,
                topicPrefix: topicPrefix
            };

            log.debug('ready: create client', clientOptions);
            var client = this.client = new ClientWrapper(clientOptions);

            // delegate event
            client.on(_constants.CHANNEL_CONNECT_STATUS_CHANGE, function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                _this.emit.apply(_this, [_constants.CHANNEL_CONNECT_STATUS_CHANGE].concat(args));
            }).connect().then(onConnect.bind(this), onConnectFailed.bind(this)).catch(onConnectFailed.bind(this));

            function onConnect() {
                log.debug('ready: connected');
                client._subscribeDefaultTopic(function (err) {
                    if (err) {
                        log.warn('ready: subscribe default topic failed', err);
                        callback(err);
                        return;
                    }

                    log.debug('ready: subscribe default topic success');
                    callback(null);
                });
            }

            function onConnectFailed(err) {
                log.warn('ready: connect failed', err);
                callback(err);
            }
        }
    }, {
        key: 'subscribe',
        value: function subscribe(_ref4, callback) {
            var _ref5 = _slicedToArray(_ref4, 1),
                topic = _ref5[0];

            this.client.on(topic, callback);
        }
    }, {
        key: 'unsubscribe',
        value: function unsubscribe(_ref6, callback) {
            var _ref7 = _slicedToArray(_ref6, 1),
                topic = _ref7[0];

            this.client.off(topic, callback);
        }
    }, {
        key: 'publish',
        value: function publish(_ref8, callback) {
            var _ref9 = _slicedToArray(_ref8, 2),
                topic = _ref9[0],
                payload = _ref9[1];

            this.client.publish([topic, payload], callback);
        }
    }, {
        key: 'request',
        value: function request(_ref10, callback) {
            var _ref11 = _slicedToArray(_ref10, 2),
                topic = _ref11[0],
                payload = _ref11[1];

            this.client.request([topic, payload], callback);
        }
    }]);

    return ChannelWebBridge;
}();

ChannelWebBridge.moduleName = _constants.CHANNEL;

var ClientWrapper = function () {
    _createClass(ClientWrapper, [{
        key: 'client',
        get: function get() {
            return this[SYMBOL_CLIENT];
        }
    }, {
        key: 'host',
        get: function get() {
            return this[SYMBOL_OPTIONS].host;
        }
    }, {
        key: 'clientId',
        get: function get() {
            return this[SYMBOL_OPTIONS].clientId;
        }
    }, {
        key: 'mqttClientId',
        get: function get() {
            return this[SYMBOL_OPTIONS].mqttClientId;
        }
    }, {
        key: 'mqttUsername',
        get: function get() {
            return this[SYMBOL_OPTIONS].mqttUsername;
        }
    }, {
        key: 'mqttPassword',
        get: function get() {
            return this[SYMBOL_OPTIONS].mqttPassword;
        }
    }, {
        key: 'topicPrefix',
        get: function get() {
            return this[SYMBOL_OPTIONS].topicPrefix;
        }
    }]);

    function ClientWrapper(_ref12) {
        var host = _ref12.host,
            clientId = _ref12.clientId,
            mqttClientId = _ref12.mqttClientId,
            mqttUsername = _ref12.mqttUsername,
            mqttPassword = _ref12.mqttPassword,
            topicPrefix = _ref12.topicPrefix;

        _classCallCheck(this, ClientWrapper);

        log.debug('client.constructor in:', {
            host: host,
            clientId: clientId,
            mqttClientId: mqttClientId,
            mqttUsername: mqttUsername,
            mqttPassword: mqttPassword,
            topicPrefix: topicPrefix
        });

        // mixin event-emitter
        Object.assign(this, _eventEmitter2.default);

        // create client
        var client = this[SYMBOL_CLIENT] = new _pahoClient2.default.Client(host, mqttClientId);
        log.debug('client.constructor: client created', client);

        // keep options
        this[SYMBOL_OPTIONS] = { host: host, clientId: clientId, mqttClientId: mqttClientId, mqttUsername: mqttUsername, mqttPassword: mqttPassword, topicPrefix: topicPrefix };

        // common message handler
        client.onMessageArrived = this._onMessageArrived.bind(this);

        // no need for deliver event
        client.onMessageDelivered = this._onMessageDelivered.bind(this);

        // connect status change
        client.onConnected = this._onConnected.bind(this);
        client.onConnectionLost = this._onConnectionLost.bind(this);
    }

    _createClass(ClientWrapper, [{
        key: 'connect',
        value: function connect() {
            var _this2 = this;

            log.debug('client.connect: connecting client');
            return new Promise(function (resolve, reject) {
                // @see http://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html
                var options = {
                    useSSL: true,
                    userName: _this2.mqttUsername,
                    password: _this2.mqttPassword,
                    // default timeout is 30s
                    // timeout: 30, 
                    // default keep-alive interval is 60s
                    // keepAliveInterval: 60,
                    reconnect: true,
                    onSuccess: resolve,
                    onFailure: reject
                };

                log.debug('client.connect options:', options);
                // connect the client
                _this2.client.connect(options);
            });
        }
    }, {
        key: '_subscribeDefaultTopic',
        value: function _subscribeDefaultTopic(callback) {
            var _this3 = this;

            log.debug('client._subscribeDefaultTopic: ' + this.topicPrefix + 'down/#');

            // subscribe default topics
            this.client.subscribe(this.topicPrefix + 'down/#', {
                // qos is meaningles in client
                qos: 0,
                onSuccess: function onSuccess() {
                    // do nothing
                    log.debug('client.connect: default topic \'' + _this3.topicPrefix + 'down/#\' subscribed');
                    callback(null);
                },
                onFailure: function onFailure(err) {
                    log.warn('client.connect: default topic \'' + _this3.topicPrefix + 'down/#\' subscribed failed');
                    callback(err);
                }
            });
        }

        /**
         * @private
         * @param {Paho.MQTT.Message} msg 
         */

    }, {
        key: '_onMessageArrived',
        value: function _onMessageArrived(rawMsg) {
            log.debug('client message received:', rawMsg);

            var topic = rawMsg.destinationName.replace(/^\/sys\/[^\/]+\/[^\/]+\/web\/down/, '');
            var msg = { topic: topic };
            try {
                msg.payload = JSON.parse(rawMsg.payloadString);
            } catch (err) {
                log.error('client message parse error:', err.message);
                return;
            }

            this.emit(topic, msg);
        }
    }, {
        key: '_onMessageDelivered',
        value: function _onMessageDelivered(msg) {
            log.debug('client message delivered:', msg);

            var topic = DELIVER_PREFIX + msg.destinationName.replace(/^\/sys\/[^\/]+\/[^\/]+\/web\/up/, '');
            this.emit(topic, msg);
        }
    }, {
        key: '_onConnected',
        value: function _onConnected() {
            this.emit(_constants.CHANNEL_CONNECT_STATUS_CHANGE, _constants.CHANNEL_CONNECT_STATUS_CONNECTED);
        }
    }, {
        key: '_onConnectionLost',
        value: function _onConnectionLost(err) {
            log.warn('client connection lost:', err);
            this.emit(_constants.CHANNEL_CONNECT_STATUS_CHANGE, _constants.CHANNEL_CONNECT_STATUS_DISCONNECTED, err);
        }
    }, {
        key: 'publish',
        value: function publish(_ref13, callback) {
            var _ref14 = _slicedToArray(_ref13, 4),
                topic = _ref14[0],
                payload = _ref14[1],
                _ref14$ = _ref14[2],
                qos = _ref14$ === undefined ? 0 : _ref14$,
                _ref14$2 = _ref14[3],
                retained = _ref14$2 === undefined ? true : _ref14$2;

            log.debug('client.publish:', this.topicPrefix + 'up' + topic, payload, qos, retained);

            try {
                typeof payload === 'object' && (payload = JSON.stringify(payload));
            } catch (err) {
                log.warn('client.publish error:', err);
                callback(err);
                return;
            }

            // bind callback on deliver event
            typeof callback === 'function' && this.one(DELIVER_PREFIX + topic, function () {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                callback.apply(undefined, [null].concat(args));
            });

            this.client.publish(this.topicPrefix + 'up' + topic, payload, qos, retained);
        }
    }, {
        key: 'request',
        value: function request(_ref15, callback) {
            var _this4 = this;

            var _ref16 = _slicedToArray(_ref15, 4),
                topic = _ref16[0],
                payload = _ref16[1],
                _ref16$ = _ref16[2],
                qos = _ref16$ === undefined ? 0 : _ref16$,
                _ref16$2 = _ref16[3],
                retained = _ref16$2 === undefined ? true : _ref16$2;

            log.debug('client.request:', this.topicPrefix + 'up' + topic, payload, qos, retained);

            this.publish([topic, payload], function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                // publish successfully
                // subscribe reply topic
                typeof callback === 'function' && _this4.one(topic + '_reply', function (msg) {
                    callback(null, msg);
                });
            });
        }
    }]);

    return ClientWrapper;
}();

exports.default = ChannelWebBridge;