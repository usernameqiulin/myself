'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('./constants');

var _eventEmitter = require('@bone/event-emitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _logger = require('@bone/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var log = _logger2.default.create({
    module: 'ChannelInterface',
    label: ['Bone', 'channel']
});

/**
 * channel接口层
 * @interface
 */

var ChannelInterface = function () {
    function ChannelInterface(_ref) {
        var bridge = _ref.bridge;

        _classCallCheck(this, ChannelInterface);

        this.EVENT_CONNECT_STATUS_CHANGE = _constants.CHANNEL_CONNECT_STATUS_CHANGE;

        /**
         * bridge引用
         * @private
         * @type {Object} 
         */
        this.bridge = bridge;

        Object.assign(this, _eventEmitter2.default);

        // delegate event
        bridge.on(_constants.CHANNEL_CONNECT_STATUS_CHANGE, onConnectStatusChange.bind(this));
    }

    /**
     * 启动接口，channel的其他接口必须等到ready之后才可以安全的调用
     * @param {Object} conf 启动配置
     * @param {String} conf.id 用户id
     * @param {String} conf.token 用户登录态token
     * @returns {Promise}
     * @example
     *  channel
     *      .ready()
     *      .then(()=>{
     *          // safe to call channel methods now
     *          channel.subscribe('/demo/push', (msg)=>{
     *              console.log(msg);
     *          });
     *      })
     *      .catch((err)=>{
     *          // initialization failed
     * 
     *          // handle error here
     *          console.error(err);
     *      });
     */

    /**
     * 连接状态变更事件名
     * @type {String}
     */


    _createClass(ChannelInterface, [{
        key: 'ready',
        value: function ready(conf) {
            var _this = this;

            log.debug('ready: waiting for interface to be ready', conf);

            return new Promise(function (resolve, reject) {
                _this.bridge.call(_constants.CHANNEL, 'ready', [conf], function (err) {
                    if (err) {
                        log.warn('ready: initialization error', err);

                        reject(err);
                        return;
                    }

                    log.debug('ready: initialization done', err);
                    resolve();
                });
            });
        }

        /**
         * 订阅topic
         * @param {String} topic 需要订阅的topic
         * @param {Function} callback topic的响应函数，注意：该函数可能被多次调用
         * @example
         *      channel.subscribe('/demo/push', (msg)=>{
         *          console.log('/demo/push message received:', msg);
         *      });
         */

    }, {
        key: 'subscribe',
        value: function subscribe(topic, callback) {
            log.debug('subscribe:', topic);
            this.bridge.call(_constants.CHANNEL, 'subscribe', [topic], callback);
        }

        /**
         * 取消订阅
         * @param {String} topic 取消订阅的topic 
         * @param {Function} callback 订阅时传入的响应函数，注意：必须是同一个函数，否则无法取消订阅
         * @example
         *      channel.unsubscribe('/demo/push', callback);
         */

    }, {
        key: 'unsubscribe',
        value: function unsubscribe(topic, callback) {
            log.debug('unsubscribe:', topic);
            this.bridge.call(_constants.CHANNEL, 'unsubscribe', [topic], callback);
        }

        /**
         * 发布topic
         * @param {String} topic 需要发布的topic
         * @param {Object} payload topic的消息内容
         * @param {Function} callback topic发布成功时的回调
         * @example
         *      channel.publish(
         *          '/demo/publish_topic', 
         *          { msg: 'hello' }
         *          ()=>{
         *              console.log('/demo/publish_topic message sent');
         *          }
         *      );
         */

    }, {
        key: 'publish',
        value: function publish(topic, payload, callback) {
            log.debug('publish:', topic, payload);
            this.bridge.call(_constants.CHANNEL, 'publish', [topic, payload], callback);
        }

        /**
         * RPC请求，即利用长连通道进行一次请求和响应的动作
         * @param {String} topic 做RPC请求的topic
         * @param {Object} payload topic的消息内容
         * @param {Function} callback RPC的响应报文回调函数
         * @example
         *      channel.request(
         *          '/demo/rpc_topic',
         *          { msg: 'hello' }
         *          (err, res)=>{
         *              if(err){
         *                  console.warn('/demo/rpc_topic message error:', err);
         *                  return;
         *              }
         * 
         *              console.log('/demo/rpc_topic response message:', res);
         *          }
         *      )
         */

    }, {
        key: 'request',
        value: function request(topic, payload, callback) {
            log.debug('request:', topic, payload);
            this.bridge.call(_constants.CHANNEL, 'request', [topic, payload], callback);
        }
    }]);

    return ChannelInterface;
}();

function onConnectStatusChange() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    /**
     * 连接状态变化事件
     * @event
     * @param {String} 当前连接状态：connected/disconnected
     */
    this.emit.apply(this, [_constants.CHANNEL_CONNECT_STATUS_CHANGE].concat(args));
}

exports.default = ChannelInterface;