<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/WebSimulatorImplement.js | @bone/channel</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="channel&#x4E3A;&#x57FA;&#x4E8E;mqtt&#x7684;&#x957F;&#x8FDE;&#x63A5;&#x901A;&#x4FE1;&#x534F;&#x8BAE;&#x5C01;&#x88C5;&#xFF0C;&#x53EF;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x5B8C;&#x6574;&#x5E93;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x5355;&#x72EC;&#x5F15;&#x7528;&#x63A5;&#x53E3;&#x5C42;&#xFF08;&#x4F7F;&#x7528;Native SDK&#x65F6;&#xFF09;&#x6216;&#x5B9E;&#x73B0;&#x5C42;&#xFF08;&#x6A21;&#x62DF;Native SDK bridge&#xFF09;"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@bone/channel"><meta property="twitter:description" content="channel&#x4E3A;&#x57FA;&#x4E8E;mqtt&#x7684;&#x957F;&#x8FDE;&#x63A5;&#x901A;&#x4FE1;&#x534F;&#x8BAE;&#x5C01;&#x88C5;&#xFF0C;&#x53EF;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x5B8C;&#x6574;&#x5E93;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x5355;&#x72EC;&#x5F15;&#x7528;&#x63A5;&#x53E3;&#x5C42;&#xFF08;&#x4F7F;&#x7528;Native SDK&#x65F6;&#xFF09;&#x6216;&#x5B9E;&#x73B0;&#x5C42;&#xFF08;&#x6A21;&#x62DF;Native SDK bridge&#xFF09;"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a href="http://gitlab.alibaba-inc.com/bone/channel.git">Repository</a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/NativeImplement.js~ChannelNativeBridge.html">ChannelNativeBridge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/WebImplement.js~ChannelWebBridge.html">ChannelWebBridge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/WebSimulatorImplement.js~ChannelWebBridge.html">ChannelWebBridge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/Interface.js~ChannelInterface.html">ChannelInterface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL">CHANNEL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_CONNECT_STATUS_CHANGE">CHANNEL_CONNECT_STATUS_CHANGE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_CONNECT_STATUS_CONNECTED">CHANNEL_CONNECT_STATUS_CONNECTED</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_CONNECT_STATUS_DISCONNECTED">CHANNEL_CONNECT_STATUS_DISCONNECTED</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_MESSAGE">CHANNEL_MESSAGE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_NA_CONNECT_STATUS_CHANGE">CHANNEL_NA_CONNECT_STATUS_CHANGE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHANNEL_NA_DOWSTREAM">CHANNEL_NA_DOWSTREAM</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/WebSimulatorImplement.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { 
    CHANNEL, 
    CHANNEL_MESSAGE, 
    CHANNEL_CONNECT_STATUS_CHANGE, 
    CHANNEL_CONNECT_STATUS_CONNECTED,
    CHANNEL_CONNECT_STATUS_DISCONNECTED
} from &apos;./constants&apos;;
import EventEmitter from &apos;@bone/event-emitter&apos;;
import logger from &apos;@bone/logger&apos;;
import Paho from &apos;@bone/paho-client&apos;;

const SYMBOL_CLIENT = Symbol(&apos;client&apos;);
const SYMBOL_OPTIONS = Symbol(&apos;options&apos;);

const log = logger.create({
    module: &apos;ChannelWebImpl&apos;,
    label: [&apos;Bone&apos;, &apos;channel&apos;]
});

// @todo
const HOST = {
    development: &apos;ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:8883/&apos;,
    test: &apos;ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:443/&apos;,
    production: &apos;ws://channel.iot-as-mqtt.cn-shanghai.aliyuncs.com:443/&apos;
};

const UA = (function(){
    const ua = navigator.userAgent.toLowerCase();
    const match = /(chrome)[ \/](\w+)\./.exec( ua ) ||
        /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
        /(opera)(?:.*version|)[ \/](\w+)\./.exec( ua ) ||
        /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf(&quot;compatible&quot;) &lt; 0 &amp;&amp; /(mozilla)(?:.*? rv:(\w+)\.|)/.exec( ua ) ||
        [];
    
    // format: browser_version
    const browser = match[1] || &apos;unknown&apos;;
    const version = match[2] || &apos;0&apos;;
    
    return browser + &apos;_&apos; + version;
})();

const DELIVER_PREFIX = &apos;_ON_MESSAGE_DELIVERED_&apos;;

class ChannelWebBridge {
    static moduleName = CHANNEL;
    
    constructor({
        bridge
    }){
        // mixin event-emitter for event dispatching
        Object.assign(this, EventEmitter);
        this.bridge = bridge;
        this.mqttOptions = {};
    }

    // fake ready
    // it&apos;s useful for web initialization
    ready([conf], callback) {
        callback = callback || function() { };
        const { clientId, mqttClientId, mqttUsername, mqttPassword, topicRoot } = this.mqttOptions;
        const topicPrefix = topicRoot;

        // ready
        if(this.client){
            callback(null);
            return;
        }

        const validProps = [&apos;clientId&apos;, &apos;mqttClientId&apos;, &apos;mqttUsername&apos;, &apos;mqttPassword&apos;, &apos;topicRoot&apos;];
        for (var i = 0; i &lt; validProps.length; ++i) {
            if (typeof this.mqttOptions[validProps[i]] !== &apos;string&apos;) {
                callback(new Error(`channel: ${validProps[i]} is required`));
                return;
            }
        }

        const env = this.env || &apos;production&apos;;
        const host = this.host = HOST[env];
        
        const clientOptions = {
            host: HOST[env],
            clientId,
            mqttClientId,
            mqttUsername,
            mqttPassword,
            topicPrefix
        };

        log.debug(&apos;ready: create client&apos;, clientOptions);
        const client = this.client = new ClientWrapper(clientOptions);

        // delegate event
        client
            .on(CHANNEL_CONNECT_STATUS_CHANGE, (...args)=&gt;{
                this.emit(CHANNEL_CONNECT_STATUS_CHANGE, ...args);
            })
            .connect()
                .then(
                    onConnect.bind(this),
                    onConnectFailed.bind(this)
               )
               .catch(onConnectFailed.bind(this));

        function onConnect(...args){
            log.debug(`ready: connected`);
            client._subscribeDefaultTopic((err)=&gt;{
                if(err){
                    log.warn(`ready: subscribe default topic failed`, err);
                    callback(err);
                    return;
                }

                log.debug(`ready: subscribe default topic success`);
                callback(null);
            });
        }

        function onConnectFailed(err){
            log.warn(`ready: connect failed`, err);
            callback(err);
        }
    }

    subscribe([topic], callback){
        this.client.on(topic, callback);
    }

    unsubscribe([topic], callback){
        this.client.off(topic, callback);
    }

    publish([topic, payload], callback){
        this.client.publish([topic, payload], callback);
    }

    request([topic, payload], callback){
        this.client.request([topic, payload], callback);
    }
}

class ClientWrapper {
    get client(){
        return this[SYMBOL_CLIENT];
    }

    get host(){
        return this[SYMBOL_OPTIONS].host;
    }

    get clientId(){
        return this[SYMBOL_OPTIONS].clientId;
    }

    get mqttClientId(){
        return this[SYMBOL_OPTIONS].mqttClientId;
    }

    get mqttUsername(){
        return this[SYMBOL_OPTIONS].mqttUsername;
    }

    get mqttPassword(){
        return this[SYMBOL_OPTIONS].mqttPassword;
    }

    get topicPrefix(){
        return this[SYMBOL_OPTIONS].topicPrefix;
    }

    constructor({
        host,
        clientId,
        mqttClientId,
        mqttUsername,
        mqttPassword,
        topicPrefix
    }){
        log.debug(&apos;client.constructor in:&apos;, {
            host,
            clientId,
            mqttClientId,
            mqttUsername,
            mqttPassword,
            topicPrefix 
        });
        
        // mixin event-emitter
        Object.assign(this, EventEmitter);

        // create client
        const client = this[SYMBOL_CLIENT] = new Paho.Client(host, mqttClientId);
        log.debug(&apos;client.constructor: client created&apos;, client);

        // keep options
        this[SYMBOL_OPTIONS] = { host, clientId, mqttClientId, mqttUsername, mqttPassword, topicPrefix };

        // common message handler
        client.onMessageArrived = this._onMessageArrived.bind(this);

        // no need for deliver event
        client.onMessageDelivered = this._onMessageDelivered.bind(this);

        // connect status change
        client.onConnected = this._onConnected.bind(this);
        client.onConnectionLost = this._onConnectionLost.bind(this);
    }

    connect(){
        log.debug(&apos;client.connect: connecting client&apos;);
        return new Promise((resolve, reject)=&gt;{
            // @see http://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html
            const options = {
                useSSL: true,
                userName: this.mqttUsername,
                password: this.mqttPassword,
                // default timeout is 30s
                // timeout: 30, 
                // default keep-alive interval is 60s
                // keepAliveInterval: 60,
                reconnect: true,
                onSuccess: resolve,
                onFailure: reject
            };
    
            log.debug(&apos;client.connect options:&apos;, options);
            // connect the client
            this.client.connect(options);
        });
    }

    _subscribeDefaultTopic(callback){
        log.debug(`client._subscribeDefaultTopic: ${this.topicPrefix}down/#`);

        // subscribe default topics
        this.client.subscribe(`${this.topicPrefix}down/#`, {
            // qos is meaningles in client
            qos: 0,
            onSuccess: ()=&gt;{
                // do nothing
                log.debug(`client.connect: default topic &apos;${this.topicPrefix}down/#&apos; subscribed`);
                callback(null);
            },
            onFailure: (err)=&gt;{
                log.warn(`client.connect: default topic &apos;${this.topicPrefix}down/#&apos; subscribed failed`);
                callback(err);
            }
        });
    }

    /**
     * @private
     * @param {Paho.MQTT.Message} msg 
     */
    _onMessageArrived(rawMsg){
        log.debug(&apos;client message received:&apos;, rawMsg);

        const topic = rawMsg.destinationName.replace(/^\/sys\/[^\/]+\/[^\/]+\/app\/down/, &apos;&apos;);
        const msg = { topic };
        try {
            msg.payload = JSON.parse(rawMsg.payloadString);
        } catch(err){
            log.error(&apos;client message parse error:&apos;, err.message);
            return;
        }

        this.emit(topic, msg);
    }

    _onMessageDelivered(msg){
        log.debug(&apos;client message delivered:&apos;, msg);

        const topic = DELIVER_PREFIX + msg.destinationName.replace(/^\/sys\/[^\/]+\/[^\/]+\/app\/up/, &apos;&apos;);
        this.emit(topic, msg);
    }

    _onConnected(){
        this.emit(CHANNEL_CONNECT_STATUS_CHANGE, CHANNEL_CONNECT_STATUS_CONNECTED);
    }

    _onConnectionLost(err){
        log.warn(&apos;client connection lost:&apos;, err);
        this.emit(CHANNEL_CONNECT_STATUS_CHANGE, CHANNEL_CONNECT_STATUS_DISCONNECTED, err);
    }

    publish([topic, payload, qos=0, retained=true], callback){
        log.debug(&apos;client.publish:&apos;, `${this.topicPrefix}up${topic}`, payload, qos, retained);

        try{
            typeof payload === &apos;object&apos; &amp;&amp; (payload = JSON.stringify(payload));
        }catch(err){
            log.warn(&apos;client.publish error:&apos;, err);
            callback(err);
            return;
        }

        // bind callback on deliver event
        typeof callback === &apos;function&apos; &amp;&amp; this.one(DELIVER_PREFIX + topic, (...args)=&gt;{
            callback(null, ...args);
        });

        this.client.publish(`${this.topicPrefix}up${topic}`, payload, qos, retained);
    }

    request([topic, payload, qos=0, retained=true], callback){
        log.debug(&apos;client.request:&apos;, `${this.topicPrefix}up${topic}`, payload, qos, retained);
        
        this.publish([topic, payload], (err)=&gt;{
            if(err){
                callback(err);
                return;
            }

            // publish successfully
            // subscribe reply topic
            typeof callback === &apos;function&apos; &amp;&amp; this.one(topic + &apos;_reply&apos;, (msg)=&gt;{
                callback(null, msg);
            });
        });
    }
}

export default ChannelWebBridge;</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
