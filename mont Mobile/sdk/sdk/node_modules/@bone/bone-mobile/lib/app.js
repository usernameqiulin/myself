'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.App = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getAppInstance = getAppInstance;
exports.default = createApp;

var _eventEmitter = require('@bone/event-emitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _logger = require('@bone/logger');

var _logger2 = _interopRequireDefault(_logger);

var _typeDetect = require('type-detect');

var _typeDetect2 = _interopRequireDefault(_typeDetect);

var _AppContainer = require('./container/AppContainer');

var _AppContainer2 = _interopRequireDefault(_AppContainer);

var _registry = require('./registry');

var _registry2 = _interopRequireDefault(_registry);

var _enums = require('./config/enums');

var _appDefConf = require('./config/appDefConf');

var _appDefConf2 = _interopRequireDefault(_appDefConf);

var _constants = require('./config/constants');

var _bridge = require('./bridge');

var _bridge2 = _interopRequireDefault(_bridge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var appSymbol = Symbol('app');
var appStateSymbol = Symbol('appState');

// @todo add basic container api
// import { bridge, app as appAPI } from './api';

var log = _logger2.default.create({
  module: 'bone-mobile',
  label: ['framework', 'framework/app']
});

var App = exports.App = function () {
  function App(conf) {
    _classCallCheck(this, App);

    // mixin EventEmitter
    Object.assign(this, _eventEmitter2.default);

    // bind life cycle events
    this.initLifeCycle();

    // prepare config
    this.conf = _extends({}, _appDefConf2.default, conf);

    // keep app instance
    App[appSymbol] = this;

    // emit appDidCreate event
    log.info('Bone app created');
    this.emit(_enums.LIFE_CYCLE_EVENTS.DID_CREATE, this);

    // start app automatically by default
    if (this.conf.autoStart !== false) {
      this.start();
    }
  }

  _createClass(App, [{
    key: 'start',
    value: function start() {
      log.info('Bone app starting');

      (0, _invariant2.default)(this[appStateSymbol] === _enums.APP_STATE.INACTIVE, 'Bone app can not be started, expected app state is INACTIVE, but ' + this[appStateSymbol] + ' got');

      var MainContainer = _AppContainer2.default;

      // support global container
      var container = this.conf.container;

      if (container) {
        (0, _invariant2.default)(typeof container === 'function', 'Bone app can not be started, container should be function, but get ' + typeof container);

        MainContainer = container(_AppContainer2.default);
        (0, _invariant2.default)(typeof MainContainer === 'function' || typeof MainContainer === 'object', 'Bone app can not be started, container should returns a react component, but get ' + typeof container);
      }

      // register & run
      // app will not be started until AppContainer is mounted
      (0, _registry2.default)(_constants.appName, MainContainer, {
        app: this,

        conf: this.conf
      });

      log.info('Bone will start');
      this.emit(_enums.LIFE_CYCLE_EVENTS.WILL_START, this);
    }
  }, {
    key: 'exit',
    value: function exit() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      log.info('Bone app is exiting...');

      this.emit(_enums.LIFE_CYCLE_EVENTS.WILL_STOP);

      // call bridge api to exit
      _bridge2.default.call('BoneApp', 'exit', [params, animated]);
    }

    // @todo
    // reload(){
    // }

  }, {
    key: 'initLifeCycle',
    value: function initLifeCycle() {
      var _this = this;

      // init app state
      this[appStateSymbol] = _enums.APP_STATE.INIT;

      // bind life cycle events to update the app state
      [
      // INIT -> INACTIVE
      [_enums.LIFE_CYCLE_EVENTS.DID_CREATE, _enums.APP_STATE.INACTIVE],

      // INACTIVE -> RUNNING
      [_enums.LIFE_CYCLE_EVENTS.WILL_START, _enums.APP_STATE.RUNNING],

      // RUNNING -> PAUSED
      [_enums.LIFE_CYCLE_EVENTS.WILL_PAUSE, _enums.APP_STATE.PAUSED],

      // PAUSED -> RUNNING
      [_enums.LIFE_CYCLE_EVENTS.DID_RESUME, _enums.APP_STATE.RUNNING],

      // RUNNING -> INACTIVE
      [_enums.LIFE_CYCLE_EVENTS.WILL_STOP, _enums.APP_STATE.INACTIVE],

      // RUNNING -> DESTROYED
      [_enums.LIFE_CYCLE_EVENTS.WILL_DESTROY, _enums.APP_STATE.DESTORYED]].map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            event = _ref2[0],
            state = _ref2[1];

        return _this.stateReducer(event, state);
      });

      // @todo
      // map old life cycle events to new ones
      _bridge2.default.on('willPause', function () {
        _this.emit(_enums.LIFE_CYCLE_EVENTS.WILL_PAUSE);
      });
      _bridge2.default.on('didResume', function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this.emit.apply(_this, [_enums.LIFE_CYCLE_EVENTS.DID_RESUME].concat(args));
      });
      _bridge2.default.on('BoneReceivedResult', function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this.emit.apply(_this, [_enums.LIFE_CYCLE_EVENTS.DID_RESUME].concat(args));
      });

      // @todo
      // implement in bridge for H5
      // document.addEventListener('pause', (e) => {
      //   this.emit(LIFE_CYCLE_EVENTS.WILL_PAUSE, e);
      // }, false);

      // document.addEventListener('resume', (e) => {
      //   this.emit(LIFE_CYCLE_EVENTS.DID_RESUME, e);
      // }, false);
    }
  }, {
    key: 'stateReducer',
    value: function stateReducer(event, state) {
      var _this2 = this;

      this.on(event, function () {
        // reducer is at the head of life cycle event queue
        // delay to next tick, so state change happens after all event queue have been executed

        // @todo app.start should be sync flow
        // setTimeout(()=> {
        _this2[appStateSymbol] = state;
        // }, 0);
      });
    }
  }]);

  return App;
}();

function getAppInstance() {
  (0, _invariant2.default)(App[appSymbol], 'App.app: you should create app before getting it');

  return App[appSymbol];
}

function createApp(conf) {
  (0, _invariant2.default)(!App[appSymbol], 'App.create: app exists already');

  (0, _invariant2.default)((0, _typeDetect2.default)(conf) === 'Object', 'App.create: configure should be assigned');

  log.info('Creating bone app');

  var app = new App(conf);

  // create interface object
  var appInf = {};
  ['start', 'exit', 'on', 'off', 'emit', 'one'].forEach(function (method) {
    appInf[method] = app[method].bind(app);
  });

  return appInf;
}