'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = logger;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SYMBOL_CONF = Symbol('conf');
var SYMBOL_FILTER = Symbol('filter');

var LEVEL = {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error'
};

var LEVEL2INT = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
};

var APPENDER = {
    CONSOLE: console
};

var DEF_CONF = {
    development: {
        level: LEVEL.DEBUG,
        appender: APPENDER.CONSOLE
    },

    test: {
        level: LEVEL.WARN,
        appender: APPENDER.CONSOLE
    },

    production: {
        level: LEVEL.ERROR,
        appender: APPENDER.CONSOLE
    }
};

var CONF = process && process.env && process.env.NODE_ENV ? DEF_CONF[process.env.NODE_ENV] : DEF_CONF.production;

var SNCounter = 0;
function sn() {
    return 'sn-' + ++SNCounter;
}

var Logger = function () {
    function Logger(conf) {
        _classCallCheck(this, Logger);

        if (typeof conf !== 'object') {
            throw new Error('logger: conf must be object');
        }

        this.conf = conf;
    }

    _createClass(Logger, [{
        key: 'log',


        /**
         * @private
         * @param {enums} level logger.LEVEL
         * @param {Array} args log arguments
         */
        value: function log(level) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            var inst = new Log({
                level: level,
                module: this.conf.module,
                message: args
            });

            // level check
            if (LEVEL2INT[level] < LEVEL2INT[logger.conf.level]) {
                return inst;
            }

            // filter check
            if (!logger.filter(inst)) {
                return inst;
            }

            this.append(inst);
            return inst;
        }

        /**
         * @private
         * @param {Log} inst 
         */

    }, {
        key: 'append',
        value: function append(inst) {
            var _logger$conf$appender;

            // copy message array
            var msg = inst.message.slice(0);

            if (!Array.isArray(msg)) {
                throw new Erro('logger: illegal log messsage');
            }

            var prefix = logPrefix(inst);

            if (typeof msg[0] === 'string') {
                // log(msg, subst1, subst2, ...)
                msg[0] = prefix + msg[0];
            } else {
                // obj
                msg.unshift(prefix);
            }

            (_logger$conf$appender = logger.conf.appender)[inst.level].apply(_logger$conf$appender, _toConsumableArray(msg));
        }
    }, {
        key: 'debug',
        value: function debug() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            return this.log.apply(this, [LEVEL.DEBUG].concat(args));
        }
    }, {
        key: 'info',
        value: function info() {
            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            return this.log.apply(this, [LEVEL.INFO].concat(args));
        }
    }, {
        key: 'warn',
        value: function warn() {
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
            }

            return this.log.apply(this, [LEVEL.WARN].concat(args));
        }
    }, {
        key: 'error',
        value: function error() {
            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
            }

            return this.log.apply(this, [LEVEL.ERROR].concat(args));
        }
    }, {
        key: 'conf',
        get: function get() {
            return this[SYMBOL_CONF];
        },
        set: function set(newConf) {
            this[SYMBOL_CONF] = Object.assign({}, this[SYMBOL_CONF], newConf);
        }
    }]);

    return Logger;
}();

;

var Log = function Log(opts) {
    _classCallCheck(this, Log);

    Object.assign(this, opts);

    this.time = new Date();
};

function create(conf) {
    return new Logger(conf);
}

function logPrefix(log) {
    return '[' + log.module + ']:[' + createTimeString(log.time) + ']:[' + log.level + '] - ';
}

function createTimeString() {
    var time = new Date();

    // YY-MM-DD HH:mm:ss.SSS
    // 17-10-30 15:35:22:123
    return (time.getFullYear() + '').slice(2) + '-' + (time.getMonth() + 1) + '-' + time.getDate() + ' ' + (time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ':' + time.getMilliseconds());
}

function logger(module) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var label = options.label;


    return create({
        module: module,
        label: label
    });
}

logger.sn = sn;
logger.create = create;

Object.defineProperties(logger, {
    conf: {
        get: function get() {
            return this[SYMBOL_CONF] || CONF;
        },
        set: function set(newConf) {
            this[SYMBOL_CONF] = Object.assign({}, this[SYMBOL_CONF], newConf);
        }
    },

    filter: {
        get: function get() {
            return this[SYMBOL_FILTER] || function () {
                // always pass by default
                return true;
            };
        },
        set: function set(filter) {
            var f = filter;

            if (Array.isArray(filter)) {
                f = function f(inst) {
                    var matches = (inst.label || []).filter(function (label) {
                        return filter.indexOf(label) > -1;
                    });

                    return matches.length > 0;
                };
            }

            this[SYMBOL_FILTER] = f;
        }
    },

    LEVEL: {
        get: function get() {
            return LEVEL;
        }
    },

    DEF_CONF: {
        get: function get() {
            return DEF_CONF;
        }
    }
});

// export logger to global
(global || window || {}).logger = logger;
//# sourceMappingURL=index.js.map